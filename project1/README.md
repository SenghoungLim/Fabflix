# General
  - #### Team#: Jake
  
  - #### Names: Thien Toan Vu & Senghoung Lim
  
  - #### Project 5 Video Demo Link: [Demo Video Link](https://youtu.be/7ldtUGrAXy8)

  - #### Instruction of deployment: No Special instruction, instructions are followed by the requirements

  - #### Collaborations and Work Distribution: Senghoung Lim (Task 1 - 3) & Thien Toan Vu (Task 3-4)


# Connection Pooling
  - #### Include the filename/path of all code/configuration files in GitHub of using JDBC Connection Pooling.
  - Context.xml
  - FulltextSearchServlet (Data source connection and prepared statement)
  - pom.xml
  Every endpoint access the database
  - #### Explain how Connection Pooling is utilized in the Fabflix code.
  - The connection pooling is unitilizaed in the search field fabflix to help manage and reuse database connections, this will help performance because doing a connection each time to the backend it can be 
  costly, but with connection pooling it can be reused and pay once. In addition, there is a limit to the connections that we created, this gives a more predictable amount of load and prevent unexpected 
  failure which can be found in context.xml with this statement "maxTotal="100" maxIdle="30" maxWaitMillis="10000"". 
  - #### Explain how Connection Pooling works with two backend SQL.
  - It works the same either with two or more backend, its job is to efficiently manage and reuse database connections to improve the performance and scalability of applications.
    

# Master/Slave
  - #### Include the filename/path of all code/configuration files in GitHub of routing queries to Master/Slave SQL.
  - All the configuration related to routing are in AWS instances.  
  - #### How read/write requests were routed to Master/Slave SQL?
  - Onec the the load balancer in instance 1 receive the requests, it will distribute the read/write requests to tomcat instances in this case Master/Slave, this will help improve the incoming traffc prevent 
    crashes to the system. 

# JMeter TS/TJ Time Logs
  - #### Instructions of how to use the `log_processing.*` script to process the JMeter logs.
  - cd 2023-fall-cs122b-jake/project1/src
  - javac log_processing.java
  - java log_processing
  - log_processing.java reads log.txt generated by FullSearchServelet.java and it calculates the TJ and TS of the request(s)


# JMeter TS/TJ Time Measurement Report

| **Single-instance Version Test Plan**          | **Graph Results Screenshot** | **Average Query Time(ms)** | **Average Search Servlet Time(ms)** | **Average JDBC Time(ms)** | **Analysis** |
|------------------------------------------------|------------------------------|----------------------------|-------------------------------------|---------------------------|--------------|
| Case 1: HTTP/1 thread                          |<img width="500" height="200" alt="SingleHTTP1" src="https://github.com/uci-jherold2-fall23-cs122b/2023-fall-cs122b-jake/assets/67763741/888c4f6c-66de-49a8-a5f0-e4b939ba27ed">| 464                        | 396.407                             | 394.116                   | This was run for 2m. Single instance version is way slower than scaled version because only one instance handling all the requests   |
| Case 2: HTTP/10 threads                        |<img width="500" height="200" alt="SingleHTTP10" src="https://github.com/uci-jherold2-fall23-cs122b/2023-fall-cs122b-jake/assets/67763741/1a573bc6-a6dc-4fb0-a3fb-94982bdf4261">| 3661                       | 3786.64                             | 3785.71                   | This was run for 2m. This takes longer on average because there are 10 threads(users) comparing to only 1 in case 1   |
| Case 3: HTTPS/10 threads                       |<img width="500" height="200" alt="SingleHTTPS10" src="https://github.com/uci-jherold2-fall23-cs122b/2023-fall-cs122b-jake/assets/67763741/ea7aa2d9-f6d5-49c0-9382-bc6469b33dc7">| 4141                       | 4169.31                             | 4168.50                   | This was run for 5m. It takes longer than case 2 because the protocol used was https rather than http   |
| Case 4: HTTP/10 threads/No connection pooling  |<img width="500" height="200" alt="SingleHTTP10NoPooling" src="https://github.com/uci-jherold2-fall23-cs122b/2023-fall-cs122b-jake/assets/67763741/08d05c4d-17ac-4815-9a30-98b0f8239a2f">
  | 3791        | 3902.53       | 3173.37                   | This was run for 2m. On average this takes longer than case 2 because connection pooling is not implemented   |

| **Scaled Version Test Plan**                   | **Graph Results Screenshot** | **Average Query Time(ms)** | **Average Search Servlet Time(ms)** | **Average JDBC Time(ms)** | **Analysis** |
|------------------------------------------------|------------------------------|----------------------------|-------------------------------------|---------------------------|--------------|
| Case 1: HTTP/1 thread                          |<img width="500" height="200" alt="ScaledHTTP1" src="https://github.com/uci-jherold2-fall23-cs122b/2023-fall-cs122b-jake/assets/67763741/d0d835a1-e8e2-4166-b1a3-a6744f4fb181">| 212                        | 185.250                             | 183.518                   | This was run for 2m. This is way faster than the single instance version because of the share of responsibilies from load balancer and the additional 2 instances    |
| Case 2: HTTP/10 threads                        |<img width="500" height="200" alt="ScaledHTTP10" src="https://github.com/uci-jherold2-fall23-cs122b/2023-fall-cs122b-jake/assets/67763741/68e5d8d4-6dc7-49c6-aa23-5ac33d64c63c">| 888                        | 847.009                             | 846.794                   | This was run for 5m. This takes longer than 4 because there's 10 threads(users) during the run |
| Case 3: HTTP/10 threads/No connection pooling  |<img width="500" height="200" alt="ScaledHTTP10NoPooling" src="https://github.com/uci-jherold2-fall23-cs122b/2023-fall-cs122b-jake/assets/67763741/b29699b9-695c-441d-9fa6-524af4b0cd42">| 889                        | 861.485                             | 824.863                   | This was run for 2m. This takes the longest out of the 3 cases for scaled version because it has 10 threads(users) and no connection pooling was implemented   |



